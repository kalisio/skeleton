import{_ as t,c as s,o,au as a}from"./chunks/framework.DtUFc-jG.js";const n="/skeleton/assets/run-tests-steps.BDUkpq-C.svg",m=JSON.parse('{"title":"Automating tests","description":"","frontmatter":{},"headers":[],"relativePath":"guides/development/automated_tests.md","filePath":"guides/development/automated_tests.md"}'),r={name:"guides/development/automated_tests.md"};function i(d,e,c,h,l,u){return o(),s("div",null,e[0]||(e[0]=[a('<h1 id="automating-tests" tabindex="-1">Automating tests <a class="header-anchor" href="#automating-tests" aria-label="Permalink to &quot;Automating tests&quot;">​</a></h1><p>We use the CI system to automate running tests we defined in the <a href="./test.html">Testing your app</a> section (API and client) .</p><h2 id="api-or-backend-tests" tabindex="-1">API (or backend) tests <a class="header-anchor" href="#api-or-backend-tests" aria-label="Permalink to &quot;API (or backend) tests&quot;">​</a></h2><p>These tests are directly run by the <code>run_tests</code> <strong>CI job</strong> (defined in the <a href="https://github.com/kalisio/skeleton/blob/master/.github/workflows/main.yaml" target="_blank" rel="noreferrer">CI workflow</a>). They run on the CI system after each push to the repo. The basically run the tests you defined in the <a href="./test.html#api">API tests</a> section.</p><p><img src="'+n+'" alt="Run tests steps"></p><p>There&#39;s also an <code>additional_tests</code> <strong>CI job</strong> whose purpose is to run the same set of API tests, but using different combinations of <code>Node.js</code> and <code>MongoDB</code> versions. This job must be explicitely triggered to run (either via the GitHub <code>Run workflow</code> button, either via a commit message containing the <code>additional tests</code> string).</p><h2 id="client-or-frontend-tests" tabindex="-1">Client (or frontend) tests <a class="header-anchor" href="#client-or-frontend-tests" aria-label="Permalink to &quot;Client (or frontend) tests&quot;">​</a></h2><p>These tests are not directly run by the CI system. Instead we build a container image using the CI system. That container image embeds everything needed to run client test (most likely <a href="https://pptr.dev/" target="_blank" rel="noreferrer">Puppeteer</a> along with the actual tests code and some reference screenshots). That container is then run <em>on the infrastructure hosting the app</em>, once a day (but it can also be run locally on a developper workstation).</p><p>The <strong>CI job</strong> responsible for building the container image is <code>build_e2e_tests</code>. It uses the <code>e2e-tests.Dockerfile</code> as recipe for the image, and embeds the <code>run_e2e_tests.sh</code> <strong>CI script</strong>, which is used as container command.</p><p>The <code>run_e2e_tests.sh</code> script is used in the container image to run the frontend tests. It&#39;s purpose is to:</p><ul><li>run the frontend tests (as defined in the <a href="./tests.html#client">Client tests</a> section)</li><li>upload all test artefacts on an S3 storage</li><li>generate a report from those tests (can be through a slack notification or as a Markdown file in a git repository)</li></ul><p>This script assumes a number of environment variables are defined, like the S3 bucket where to push the artefacts, like the git repository URL where to push reports. Please check in the <code>run_e2e_tests.sh</code> script to know which environment variables are needed.</p>',12)]))}const f=t(r,[["render",i]]);export{m as __pageData,f as default};
